<svelte:window
	on:resize=resize__items()
	on:touchstart=__mousedown__window(event)
	on:touchmove=__mousemove__window(event)
	on:touchleave=__mouseup__window(event)
	on:touchcancel=__mouseup__window(event)
	on:mousedown=__mousedown__window(event)
	on:mousemove=__mousemove__window(event)
	on:mouseup=__mouseup__window(event)
></svelte:window>

<div
	ref:Carousel
	class="Carousel {class__Carousel}"
>
	<div class="prev button" on:click=prev()>
		<Icon name="chevron-left"></Icon>
	</div>
	<div class="next button" on:click=next()>
		<Icon name="chevron-right"></Icon>
	</div>
	<div class="items" style="{style__items}" ref:items>
		<slot></slot>
	</div>
</div>

<style type="text/scss" @lang="sass">
	@import '__/css/variables';
	.Carousel {
		width: 100%;
		height: 100%;
		position: absolute;
		&.loading {
			background-color: rgba($blue, 0.6);
			> .items {
				visibility: hidden;
			}
		}
		&.is__mousedown {
			.button {
				cursor: auto;
			}
			> .items {
				cursor: grabbing;
			}
		}
		.button {
			display: block;
			position: absolute;
			top: calc(50% - 2.5rem);
			width: 5rem;
			height: 5rem;
			opacity: 0.4;
			@media(max-width: 768px) {
				height: 3rem;
				width: 3rem;
			}
			&:hover {
				opacity: 0.8;
			}
			&.prev {
				left: 0;
				z-index: 2;
			}
			&.next {
				right: 0;
				z-index: 2;
			}
			:global(svg) {
				width: 100%;
				height: 100%;
			}
		}
		> .items {
			width: 100%;
			height: 100%;
			overflow: visible;
			display: flex;
			flex-direction: row;
		}
	}
</style>

<script>
	import { assign } from 'ctx-core/object/lib.mjs'
	import { _class, _style } from 'ctx-core/html/lib.mjs'
	import Icon from 'svelte-awesome/components/Icon.html'
	import { register__chevron_left, register__chevron_right } from 'ctx-core/svelte-awesome/lib.mjs'
	export default {
		data() {
			return {
				loading: true,
				index: 0,
				transition__item: '',
				period__interval: 10000,
				transition_duration: 1000,
				translateX: 0,
				is__mousedown: false,
				clientX__mousedown: null,
				clientX__mousemove: null
			}
		},
		setup() {
			register__chevron_left(Icon)
			register__chevron_right(Icon)
		},
		oncreate() {
			this.setInterval__background_image()
			this.resize__items()
			this.set({ loading: false })
		},
		ondestroy() {
			this.clearInterval__background_image()
		},
		onstate({ changed, current }) {
			if (changed.array__ctx__style__item) {
				const { array__ctx__style__item } = current
				for (let i = 0; i < array__ctx__style__item.length; i++) {
					const ctx__style__item = array__ctx__style__item[i]
					const { item, style } = ctx__style__item
					try {
						assign(item.style, style)
					} catch (e) {
						console.debug('onstate|catch|debug|1', {
							item,
							style,
							i,
							ctx__style__item,
							array__ctx__style__item,
							changed,
							current,
						})
						throw e
					}
				}
			}
		},
		computed: {
			style__items: (
				{
					index,
					width,
					length__items,
					updating,
					transform__updating,
					transition_duration,
					translateX
				}) =>
				_style({
					width: `${width * length__items}px`,
					transition: updating ? `${transition_duration}ms ease-out` : 0,
					transform: !updating || transform__updating ? `translate(${translateX}px)` : '',
				}) || '',
			index__last: ({ length__items }) =>
				length__items - 1,
			index__previous: ({ index, index__last }) =>
				index ? index - 1 : index__last,
			index__next: ({ index, index__last }) =>
				(index < index__last) ? index + 1 : 0,
			array__ctx__style__item: (
				{
					items,
					index,
					index__last,
					index__previous,
					index__next,
					width,
					height,
					length__items
				}
			) => {
				const array__ctx__style__item = []
				for (let i = 0; i < length__items; i++) {
					const px__left = _px__left(i, {
						index,
						index__previous,
						index__next,
						width
					})
					array__ctx__style__item.push({
						item: items.children[i],
						style: {
							position: 'absolute',
							top: 0,
							left: `${px__left}px`,
							height: `${height}px`,
							width: `${width}px`,
							'z-index': 1,
						}
					})
				}
				return array__ctx__style__item
			},
			class__Carousel: ({ loading, updating, is__mousedown }) =>
				_class({ loading, updating, is__mousedown }),
		},
		methods: {
			resize__items() {
				const { Carousel, items } = this.refs
				const width = parseFloat(getComputedStyle(Carousel).width)
				const height = parseFloat(getComputedStyle(items).height)
				const { children } = items
				const length__items = children.length
				this.set({ items, width, height, length__items })
			},
			setInterval__background_image() {
				this.clearInterval__background_image()
				const interval__background_image = setInterval(
					() => this.next(),
					this.get().period__interval)
				this.set({ interval__background_image })
			},
			clearInterval__background_image() {
				const { interval__background_image } = this.get()
				if (interval__background_image) {
					clearInterval(interval__background_image)
				}
				this.set({ interval__background_image: null })
			},
			next() {
				const { length__items } = this.get()
				const index = (this.get().index + 1) % length__items
				this.set__index(index)
			},
			prev() {
				const { length__items } = this.get()
				const index = (length__items + this.get().index - 1) % length__items
				this.set__index(index)
			},
			set__index(index__transition) {
				const { transition_duration } = this.get()
				const px__left = -1 * _px__left(index__transition, this.get())
				this.clearInterval__background_image()
				this.set({ updating: true })
				setTimeout(() => {
					this.set({ transform__updating: true, translateX: px__left })
					setTimeout(() => {
						this.set({ updating: false, transform__updating: false })
						setTimeout(() => {
							this.set({ index: index__transition, translateX: 0 })
							this.setInterval__background_image()
						}, 0)
					}, transition_duration)
				}, 100)
			},
			__mousedown__window(event) {
				const { Carousel } = this.refs
				const { top, left, height, width } = Carousel.getBoundingClientRect()
				const { clientX, clientY } = event
				const active = clientY >= top && clientY <= (top + height) && clientX >= left && clientX <= (left + width)
				if (active) {
					this.set({
						is__mousedown: true,
						clientX__mousedown: clientX
					})
				}
			},
			__mousemove__window(event) {
				if (!this.get().is__mousedown) return
				const { clientX } = event
				const { clientX__mousedown } = this.get()
				this.set({
					translateX: clientX - clientX__mousedown,
					clientX__mousemove: clientX
				})
			},
			__mouseup__window(event) {
				if (!this.get().is__mousedown) return
				const { clientX } = event
				const { clientX__mousedown } = this.get()
				const clientX__diff = clientX - clientX__mousedown
				this.set({
					is__mousedown: false,
					translateX: clientX__diff + 200,
					clientX__mousedown: null,
					clientX__mousemove: null
				})
				if (clientX__diff >= 50) {
					this.prev()
				} else if (clientX__diff <= -50) {
					this.next()
				} else {
					this.set({
						translateX: 0
					})
				}
			}
		},
		components: {
			Icon
		}
	}
	function _px__left(i, state = {}) {
		const { index, index__previous, index__next, width } = state
		return (
			i == index
			? 0
			: i == index__previous
				? -width
				: i == index__next
					? width
					: width * (i - index)
		)
	}
</script>