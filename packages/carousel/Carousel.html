<svelte:options bind:props={props}/>

<script>
	import { onMount, onDestroy, getContext } from 'svelte'
	import { writable } from 'svelte/store.mjs'
	import { assign } from '@ctx-core/object/lib.js'
	import { _class, _style } from '@ctx-core/html/lib.js'
	import { get } from '@ctx-core/store/lib.js'
	import { _has__dom } from '@ctx-core/dom/lib.js'
	import Icon from '@ctx-core/font-awesome/Icon.html'
	import { register__chevron_left_solid, register__chevron_right_solid } from '@ctx-core/font-awesome/lib.js'
	export let loading = true
	export let index = 0
	export let period__interval = 10000
	export let transition_duration = 500
	export let translateX = 0
	export let is__touchstart = false
	export let clientX__mousedown = null
	export let clientX__mousemove = null
	export let updating = null
	export const bind__hack = writable()
	let dom__Carousel, height, interval__background_image, dom__items
	const width = writable()
	const transition_duration__ = writable(transition_duration)
	const translateX__ = writable(translateX)
	const loading__ = writable(loading)
	const updating__ = writable(updating)
	const is__touchstart__ = writable(is__touchstart)
	const items = writable()
	let props
	const class__ = props.class
	items.subscribe($items => {
		if (!$items) return
		resize__items()
	})
	$: class__Carousel = _class({
		loading: $loading__,
		updating: $updating__,
		is__touchstart: $is__touchstart__,
	})
	$: style__items =
		_style({
			width: `${$width * _length__items($items)}px`,
			transition: $updating__ ? `${$transition_duration__}ms ease-out` : 0,
			transform: $translateX__ ? `translate(${$translateX__}px)` : '',
		})
	register__chevron_left_solid(Icon)
	register__chevron_right_solid(Icon)
	if (_has__dom()) {
	console.debug('Carousel|debug|1', {
		getContext: getContext(),
	})
		onMount(() => {
			loading__.set(true)
			bind__hack.set(true)
			setTimeout(() => {
				items.set(dom__items)
				setInterval__background_image()
				resize__items()
				loading__.set(false)
			})
		})
		onDestroy(() => {
			clearInterval__background_image()
		})
	}
	function _length__items() {
		return dom__items && dom__items.children.length
	}
	function _index__last() {
		return _length__items() - 1
	}
	function _index__previous() {
		return index ? index - 1 : _index__last()
	}
	function _index__next() {
		return (index < _index__last()) ? index + 1 : 0
	}
	function resize__items() {
		const $width = dom__Carousel && parseFloat(getComputedStyle(dom__Carousel).width)
		width.set($width)
		height = dom__items && parseFloat(getComputedStyle(dom__items).height)
		for (let i = 0; i < _length__items(); i++) {
			const px__left = _px__left(i)
			const item = dom__items.children[i]
			const style = {
				position: 'absolute',
				top: 0,
				left: `${px__left}px`,
				height: `${height}px`,
				width: `${$width}px`,
				'z-index': 1,
			}
			assign(item.style, style)
		}
	}
	function next() {
		setTimeout(() => {
			const index__transition = (index + 1) % _length__items()
			set__index(index__transition)
		})
	}
	function prev() {
		setTimeout(() => {
			const length__items = _length__items()
			const index__transition = (length__items + index - 1) % length__items
			set__index(index__transition)
		})
	}
	function clearInterval__background_image() {
		if (interval__background_image) {
			clearInterval(interval__background_image)
		}
		interval__background_image = null
	}
	function setInterval__background_image() {
		clearInterval__background_image()
		interval__background_image = setInterval(
			() => {
				next(dom__items)
			},
			period__interval)
	}
	function set__index(index__transition) {
		clearInterval__background_image()
		updating__.set(true)
		setTimeout(() => {
			const px__left = -1 * _px__left(index__transition)
			translateX__.set(px__left)
			setTimeout(() => {
				if (!get(updating__)) {
					return
				}
				updating__.set(false)
				setTimeout(() => {
					index = index__transition
					resize__items()
					translateX__.set(0)
					setInterval__background_image()
				}, 0)
			}, get(transition_duration__))
		}, 100)
	}
	function __mousedown__window(event) {
		const { top, left, height, width } = dom__Carousel.getBoundingClientRect()
		const { clientX, clientY } = event
		const active = clientY >= top && clientY <= (top + height) && clientX >= left && clientX <= (left + width)
		if (active) {
			is__touchstart__.set(true)
			clientX__mousedown = clientX - get(translateX__)
			updating__.set(false)
		}
	}
	function __mousemove__window(event) {
		if (!get(is__touchstart__)) return
		const { clientX } = event
		translateX__.set(clientX - clientX__mousedown)
		clientX__mousemove = clientX
	}
	function __touchstart__window(event) {
		__mousedown__window(event.changedTouches[0])
	}
	function __touchmove__window(event) {
		__mousemove__window(event.changedTouches[0])
	}
	function __touchend__window(event) {
		__mouseup__window(event.changedTouches[0], dom__items)
	}
	function __touchleave__window(event) {
		__mouseup__window(event.changedTouches[0], dom__items)
	}
	function __touchcancel__window(event) {
		__mouseup__window(event.changedTouches[0], dom__items)
	}
	function __mouseup__window(event) {
		if (!get(is__touchstart__)) return
		const { clientX } = event
		const clientX__diff = clientX - clientX__mousedown
		is__touchstart__.set(false)
		clientX__mousedown = null
		clientX__mousemove = null
		if (clientX__diff > 0) {
			translateX__.set(clientX__diff)
			prev()
		} else if (clientX__diff < 0) {
			translateX__.set(clientX__diff)
			next()
		} else {
			translateX__.set(0)
		}
	}
	function _px__left(i) {
		return (
			i == index
			? 0
			: i == _index__previous()
				? -get(width)
				: i == _index__next()
					? get(width)
					: get(width) * (i - index)
		)
	}
</script>

<style type="text/scss">
	.Carousel {
		width: 100%;
		height: 100%;
		position: absolute;
		&.loading {
			> .items {
				visibility: hidden;
			}
		}
		&.is__touchstart {
			.button {
				cursor: auto;
			}
			> .items {
				cursor: grabbing;
			}
		}
		.button {
			display: block;
			position: absolute;
			top: calc(50% - 2.5rem);
			width: 5rem;
			height: 5rem;
			opacity: 0.4;
			@media(max-width: 768px) {
				height: 3rem;
				width: 3rem;
			}
			&:hover {
				opacity: 0.8;
			}
			&.prev {
				left: 0;
				z-index: 2;
			}
			&.next {
				right: 0;
				z-index: 2;
			}
			:global(svg) {
				width: 100%;
				height: 100%;
			}
		}
		> .items {
			width: 100%;
			height: 100%;
			overflow: visible;
			display: flex;
			flex-direction: row;
		}
	}
</style>

<svelte:window
	on:resize={resize__items}
	on:touchstart="{event => __touchstart__window(event)}"
	on:touchmove="{event => __touchmove__window(event)}"
	on:touchend="{event => __touchend__window(event)}"
	on:touchleave="{event => __touchleave__window(event)}"
	on:touchcancel="{event => __touchcancel__window(event)}"
	on:mousedown="{event => __mousedown__window(event)}"
	on:mousemove="{event => __mousemove__window(event)}"
	on:mouseup="{event => __mouseup__window(event)}"
></svelte:window>

<div
	bind:this={dom__Carousel}
	class="Carousel {class__Carousel} {class__}"
	bind__hack="{$bind__hack}"
>
	<div class="prev button" on:click={prev}>
		<Icon name="chevron-left-solid"></Icon>
	</div>
	<div class="next button" on:click={next}>
		<Icon name="chevron-right-solid"></Icon>
	</div>
	<div bind:this={dom__items} class="items" style="{style__items}">
		<slot></slot>
	</div>
</div>
